/*
Baserow API spec

For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).

API version: 1.18.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DatabaseTableFieldsApiService DatabaseTableFieldsApi service
type DatabaseTableFieldsApiService service

type ApiCreateDatabaseTableFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	fieldCreateField *FieldCreateField
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiCreateDatabaseTableFieldRequest) ClientSessionId(clientSessionId string) ApiCreateDatabaseTableFieldRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiCreateDatabaseTableFieldRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiCreateDatabaseTableFieldRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiCreateDatabaseTableFieldRequest) FieldCreateField(fieldCreateField FieldCreateField) ApiCreateDatabaseTableFieldRequest {
	r.fieldCreateField = &fieldCreateField
	return r
}

func (r ApiCreateDatabaseTableFieldRequest) Execute() (*FieldFieldSerializerWithRelatedFields, *http.Response, error) {
	return r.ApiService.CreateDatabaseTableFieldExecute(r)
}

/*
CreateDatabaseTableField Method for CreateDatabaseTableField

Creates a new field for the table related to the provided `table_id` parameter if the authorized user has access to the related database's workspace. Depending on the type, different properties can optionally be set.If creating the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Creates a new field for the provided table related to the value.
 @return ApiCreateDatabaseTableFieldRequest
*/
func (a *DatabaseTableFieldsApiService) CreateDatabaseTableField(ctx context.Context, tableId int32) ApiCreateDatabaseTableFieldRequest {
	return ApiCreateDatabaseTableFieldRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return FieldFieldSerializerWithRelatedFields
func (a *DatabaseTableFieldsApiService) CreateDatabaseTableFieldExecute(r ApiCreateDatabaseTableFieldRequest) (*FieldFieldSerializerWithRelatedFields, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldFieldSerializerWithRelatedFields
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.CreateDatabaseTableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/table/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.fieldCreateField
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabaseTableFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	fieldId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiDeleteDatabaseTableFieldRequest) ClientSessionId(clientSessionId string) ApiDeleteDatabaseTableFieldRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiDeleteDatabaseTableFieldRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiDeleteDatabaseTableFieldRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiDeleteDatabaseTableFieldRequest) Execute() (*RelatedFields, *http.Response, error) {
	return r.ApiService.DeleteDatabaseTableFieldExecute(r)
}

/*
DeleteDatabaseTableField Method for DeleteDatabaseTableField

Deletes the existing field if the authorized user has access to the related database's workspace. Note that all the related data to that field is also deleted. Primary fields cannot be deleted because their value represents the row. If deleting the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId Deletes the field related to the provided value.
 @return ApiDeleteDatabaseTableFieldRequest
*/
func (a *DatabaseTableFieldsApiService) DeleteDatabaseTableField(ctx context.Context, fieldId int32) ApiDeleteDatabaseTableFieldRequest {
	return ApiDeleteDatabaseTableFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
	}
}

// Execute executes the request
//  @return RelatedFields
func (a *DatabaseTableFieldsApiService) DeleteDatabaseTableFieldExecute(r ApiDeleteDatabaseTableFieldRequest) (*RelatedFields, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RelatedFields
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.DeleteDatabaseTableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/{field_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"field_id"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DeleteDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetDatabaseTableField404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDuplicateTableFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	fieldId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiDuplicateTableFieldRequest) ClientSessionId(clientSessionId string) ApiDuplicateTableFieldRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiDuplicateTableFieldRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiDuplicateTableFieldRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiDuplicateTableFieldRequest) Execute() (*SingleDuplicateFieldJobType, *http.Response, error) {
	return r.ApiService.DuplicateTableFieldExecute(r)
}

/*
DuplicateTableField Method for DuplicateTableField

Duplicates the table with the provided `table_id` parameter if the authorized user has access to the database's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId The field to duplicate.
 @return ApiDuplicateTableFieldRequest
*/
func (a *DatabaseTableFieldsApiService) DuplicateTableField(ctx context.Context, fieldId int32) ApiDuplicateTableFieldRequest {
	return ApiDuplicateTableFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
	}
}

// Execute executes the request
//  @return SingleDuplicateFieldJobType
func (a *DatabaseTableFieldsApiService) DuplicateTableFieldExecute(r ApiDuplicateTableFieldRequest) (*SingleDuplicateFieldJobType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleDuplicateFieldJobType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.DuplicateTableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/{field_id}/duplicate/async/"
	localVarPath = strings.Replace(localVarPath, "{"+"field_id"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DuplicateTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetDatabaseTableField404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseFieldUniqueRowValuesRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	fieldId int32
	limit *int32
	splitCommaSeparated *bool
}

// Defines how many values should be returned.
func (r ApiGetDatabaseFieldUniqueRowValuesRequest) Limit(limit int32) ApiGetDatabaseFieldUniqueRowValuesRequest {
	r.limit = &limit
	return r
}

// Indicates whether the original column values must be splitted by comma.
func (r ApiGetDatabaseFieldUniqueRowValuesRequest) SplitCommaSeparated(splitCommaSeparated bool) ApiGetDatabaseFieldUniqueRowValuesRequest {
	r.splitCommaSeparated = &splitCommaSeparated
	return r
}

func (r ApiGetDatabaseFieldUniqueRowValuesRequest) Execute() (*UniqueRowValues, *http.Response, error) {
	return r.ApiService.GetDatabaseFieldUniqueRowValuesExecute(r)
}

/*
GetDatabaseFieldUniqueRowValues Method for GetDatabaseFieldUniqueRowValues

Returns a list of all the unique row values for an existing field, sorted in order of frequency.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId Returns the values related to the provided field.
 @return ApiGetDatabaseFieldUniqueRowValuesRequest
*/
func (a *DatabaseTableFieldsApiService) GetDatabaseFieldUniqueRowValues(ctx context.Context, fieldId int32) ApiGetDatabaseFieldUniqueRowValuesRequest {
	return ApiGetDatabaseFieldUniqueRowValuesRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
	}
}

// Execute executes the request
//  @return UniqueRowValues
func (a *DatabaseTableFieldsApiService) GetDatabaseFieldUniqueRowValuesExecute(r ApiGetDatabaseFieldUniqueRowValuesRequest) (*UniqueRowValues, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UniqueRowValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.GetDatabaseFieldUniqueRowValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/{field_id}/unique_row_values/"
	localVarPath = strings.Replace(localVarPath, "{"+"field_id"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.splitCommaSeparated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "split_comma_separated", r.splitCommaSeparated, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetDatabaseTableField404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseTableFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	fieldId int32
}

func (r ApiGetDatabaseTableFieldRequest) Execute() (*FieldField, *http.Response, error) {
	return r.ApiService.GetDatabaseTableFieldExecute(r)
}

/*
GetDatabaseTableField Method for GetDatabaseTableField

Returns the existing field if the authorized user has access to the related database's workspace. Depending on the type different properties could be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId Returns the field related to the provided value.
 @return ApiGetDatabaseTableFieldRequest
*/
func (a *DatabaseTableFieldsApiService) GetDatabaseTableField(ctx context.Context, fieldId int32) ApiGetDatabaseTableFieldRequest {
	return ApiGetDatabaseTableFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
	}
}

// Execute executes the request
//  @return FieldField
func (a *DatabaseTableFieldsApiService) GetDatabaseTableFieldExecute(r ApiGetDatabaseTableFieldRequest) (*FieldField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.GetDatabaseTableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/{field_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"field_id"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetDatabaseTableField404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatabaseTableFieldsRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	tableId int32
}

func (r ApiListDatabaseTableFieldsRequest) Execute() ([]FieldField, *http.Response, error) {
	return r.ApiService.ListDatabaseTableFieldsExecute(r)
}

/*
ListDatabaseTableFields Method for ListDatabaseTableFields

Lists all the fields of the table related to the provided parameter if the user has access to the related database's workspace. If the workspace is related to a template, then this endpoint will be publicly accessible. A table consists of fields and each field can have a different type. Each type can have different properties. A field is comparable with a regular table's column.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Returns only the fields of the table related to the provided value.
 @return ApiListDatabaseTableFieldsRequest
*/
func (a *DatabaseTableFieldsApiService) ListDatabaseTableFields(ctx context.Context, tableId int32) ApiListDatabaseTableFieldsRequest {
	return ApiListDatabaseTableFieldsRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return []FieldField
func (a *DatabaseTableFieldsApiService) ListDatabaseTableFieldsExecute(r ApiListDatabaseTableFieldsRequest) ([]FieldField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FieldField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.ListDatabaseTableFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/table/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTypeFormulaFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	tableId int32
	typeFormulaRequest *TypeFormulaRequest
}

func (r ApiTypeFormulaFieldRequest) TypeFormulaRequest(typeFormulaRequest TypeFormulaRequest) ApiTypeFormulaFieldRequest {
	r.typeFormulaRequest = &typeFormulaRequest
	return r
}

func (r ApiTypeFormulaFieldRequest) Execute() (*TypeFormulaResult, *http.Response, error) {
	return r.ApiService.TypeFormulaFieldExecute(r)
}

/*
TypeFormulaField Method for TypeFormulaField

Calculates and returns the type of the specified formula value. Does not change the state of the field in any way.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId The table id of the formula field to type.
 @return ApiTypeFormulaFieldRequest
*/
func (a *DatabaseTableFieldsApiService) TypeFormulaField(ctx context.Context, tableId int32) ApiTypeFormulaFieldRequest {
	return ApiTypeFormulaFieldRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return TypeFormulaResult
func (a *DatabaseTableFieldsApiService) TypeFormulaFieldExecute(r ApiTypeFormulaFieldRequest) (*TypeFormulaResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TypeFormulaResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.TypeFormulaField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/formula/{table_id}/type/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.typeFormulaRequest == nil {
		return localVarReturnValue, nil, reportError("typeFormulaRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.typeFormulaRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TypeFormulaField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDatabaseTableFieldRequest struct {
	ctx context.Context
	ApiService *DatabaseTableFieldsApiService
	fieldId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	patchedFieldUpdateField *PatchedFieldUpdateField
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiUpdateDatabaseTableFieldRequest) ClientSessionId(clientSessionId string) ApiUpdateDatabaseTableFieldRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiUpdateDatabaseTableFieldRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiUpdateDatabaseTableFieldRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiUpdateDatabaseTableFieldRequest) PatchedFieldUpdateField(patchedFieldUpdateField PatchedFieldUpdateField) ApiUpdateDatabaseTableFieldRequest {
	r.patchedFieldUpdateField = &patchedFieldUpdateField
	return r
}

func (r ApiUpdateDatabaseTableFieldRequest) Execute() (*FieldFieldSerializerWithRelatedFields, *http.Response, error) {
	return r.ApiService.UpdateDatabaseTableFieldExecute(r)
}

/*
UpdateDatabaseTableField Method for UpdateDatabaseTableField

Updates the existing field if the authorized user has access to the related database's workspace. The type can also be changed and depending on that type, different additional properties can optionally be set. If you change the field type it could happen that the data conversion fails, in that case the `ERROR_CANNOT_CHANGE_FIELD_TYPE` is returned, but this rarely happens. If a data value cannot be converted it is set to `null` so data might go lost.If updated the field causes other fields to change then the specificinstances of those fields will be included in the related fields response key.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fieldId Updates the field related to the provided value.
 @return ApiUpdateDatabaseTableFieldRequest
*/
func (a *DatabaseTableFieldsApiService) UpdateDatabaseTableField(ctx context.Context, fieldId int32) ApiUpdateDatabaseTableFieldRequest {
	return ApiUpdateDatabaseTableFieldRequest{
		ApiService: a,
		ctx: ctx,
		fieldId: fieldId,
	}
}

// Execute executes the request
//  @return FieldFieldSerializerWithRelatedFields
func (a *DatabaseTableFieldsApiService) UpdateDatabaseTableFieldExecute(r ApiUpdateDatabaseTableFieldRequest) (*FieldFieldSerializerWithRelatedFields, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FieldFieldSerializerWithRelatedFields
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableFieldsApiService.UpdateDatabaseTableField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/fields/{field_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"field_id"+"}", url.PathEscape(parameterValueToString(r.fieldId, "fieldId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.patchedFieldUpdateField
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UpdateDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetDatabaseTableField404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

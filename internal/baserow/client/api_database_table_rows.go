/*
Baserow API spec

For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).

API version: 1.18.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DatabaseTableRowsApiService DatabaseTableRowsApi service
type DatabaseTableRowsApiService service

type ApiBatchCreateDatabaseTableRowsRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId int32
	exampleBatchRowsRequest *ExampleBatchRowsRequest
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	before *int32
	userFieldNames *bool
}

func (r ApiBatchCreateDatabaseTableRowsRequest) ExampleBatchRowsRequest(exampleBatchRowsRequest ExampleBatchRowsRequest) ApiBatchCreateDatabaseTableRowsRequest {
	r.exampleBatchRowsRequest = &exampleBatchRowsRequest
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiBatchCreateDatabaseTableRowsRequest) ClientSessionId(clientSessionId string) ApiBatchCreateDatabaseTableRowsRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiBatchCreateDatabaseTableRowsRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiBatchCreateDatabaseTableRowsRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

// If provided then the newly created rows will be positioned before the row with the provided id.
func (r ApiBatchCreateDatabaseTableRowsRequest) Before(before int32) ApiBatchCreateDatabaseTableRowsRequest {
	r.before = &before
	return r
}

// A flag query parameter which if provided this endpoint will expect and return the user specified field names instead of internal Baserow field names (field_123 etc).
func (r ApiBatchCreateDatabaseTableRowsRequest) UserFieldNames(userFieldNames bool) ApiBatchCreateDatabaseTableRowsRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiBatchCreateDatabaseTableRowsRequest) Execute() (*ExampleBatchRowsResponse, *http.Response, error) {
	return r.ApiService.BatchCreateDatabaseTableRowsExecute(r)
}

/*
BatchCreateDatabaseTableRows Method for BatchCreateDatabaseTableRows

Creates new rows in the table if the user has access to the related table's workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.

 **WARNING:** This endpoint doesn't yet work with row created webhooks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Creates the rows in the table.
 @return ApiBatchCreateDatabaseTableRowsRequest
*/
func (a *DatabaseTableRowsApiService) BatchCreateDatabaseTableRows(ctx context.Context, tableId int32) ApiBatchCreateDatabaseTableRowsRequest {
	return ApiBatchCreateDatabaseTableRowsRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleBatchRowsResponse
func (a *DatabaseTableRowsApiService) BatchCreateDatabaseTableRowsExecute(r ApiBatchCreateDatabaseTableRowsRequest) (*ExampleBatchRowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleBatchRowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.BatchCreateDatabaseTableRows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/batch/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exampleBatchRowsRequest == nil {
		return localVarReturnValue, nil, reportError("exampleBatchRowsRequest is required and must be specified")
	}

	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "")
	}
	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.exampleBatchRowsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BatchCreateDatabaseTableRows400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchDeleteDatabaseTableRowsRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId int32
	batchDeleteRows *BatchDeleteRows
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

func (r ApiBatchDeleteDatabaseTableRowsRequest) BatchDeleteRows(batchDeleteRows BatchDeleteRows) ApiBatchDeleteDatabaseTableRowsRequest {
	r.batchDeleteRows = &batchDeleteRows
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiBatchDeleteDatabaseTableRowsRequest) ClientSessionId(clientSessionId string) ApiBatchDeleteDatabaseTableRowsRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiBatchDeleteDatabaseTableRowsRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiBatchDeleteDatabaseTableRowsRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiBatchDeleteDatabaseTableRowsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchDeleteDatabaseTableRowsExecute(r)
}

/*
BatchDeleteDatabaseTableRows Method for BatchDeleteDatabaseTableRows

Deletes existing rows in the table if the user has access to the table's workspace.

 **WARNING:**  This endpoint doesn't yet work with row deleted webhooks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Deletes the rows in the table related to the value.
 @return ApiBatchDeleteDatabaseTableRowsRequest
*/
func (a *DatabaseTableRowsApiService) BatchDeleteDatabaseTableRows(ctx context.Context, tableId int32) ApiBatchDeleteDatabaseTableRowsRequest {
	return ApiBatchDeleteDatabaseTableRowsRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
func (a *DatabaseTableRowsApiService) BatchDeleteDatabaseTableRowsExecute(r ApiBatchDeleteDatabaseTableRowsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.BatchDeleteDatabaseTableRows")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/batch-delete/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchDeleteRows == nil {
		return nil, reportError("batchDeleteRows is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.batchDeleteRows
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BatchDeleteDatabaseTableRows400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchUpdateDatabaseTableRowsRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	userFieldNames *bool
	patchedExampleBatchUpdateRowsRequest *PatchedExampleBatchUpdateRowsRequest
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiBatchUpdateDatabaseTableRowsRequest) ClientSessionId(clientSessionId string) ApiBatchUpdateDatabaseTableRowsRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiBatchUpdateDatabaseTableRowsRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiBatchUpdateDatabaseTableRowsRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

// A flag query parameter which if provided this endpoint will expect and return the user specified field names instead of internal Baserow field names (field_123 etc).
func (r ApiBatchUpdateDatabaseTableRowsRequest) UserFieldNames(userFieldNames bool) ApiBatchUpdateDatabaseTableRowsRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiBatchUpdateDatabaseTableRowsRequest) PatchedExampleBatchUpdateRowsRequest(patchedExampleBatchUpdateRowsRequest PatchedExampleBatchUpdateRowsRequest) ApiBatchUpdateDatabaseTableRowsRequest {
	r.patchedExampleBatchUpdateRowsRequest = &patchedExampleBatchUpdateRowsRequest
	return r
}

func (r ApiBatchUpdateDatabaseTableRowsRequest) Execute() (*ExampleBatchRowsResponse, *http.Response, error) {
	return r.ApiService.BatchUpdateDatabaseTableRowsExecute(r)
}

/*
BatchUpdateDatabaseTableRows Method for BatchUpdateDatabaseTableRows

Updates existing rows in the table if the user has access to the related table's workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided for each row. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.

 **WARNING:** This endpoint doesn't yet work with row updated webhooks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Updates the rows in the table.
 @return ApiBatchUpdateDatabaseTableRowsRequest
*/
func (a *DatabaseTableRowsApiService) BatchUpdateDatabaseTableRows(ctx context.Context, tableId int32) ApiBatchUpdateDatabaseTableRowsRequest {
	return ApiBatchUpdateDatabaseTableRowsRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleBatchRowsResponse
func (a *DatabaseTableRowsApiService) BatchUpdateDatabaseTableRowsExecute(r ApiBatchUpdateDatabaseTableRowsRequest) (*ExampleBatchRowsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleBatchRowsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.BatchUpdateDatabaseTableRows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/batch/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.patchedExampleBatchUpdateRowsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BatchCreateDatabaseTableRows400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	before *int32
	userFieldNames *bool
	exampleRowRequestSerializerWithUserFieldNames *ExampleRowRequestSerializerWithUserFieldNames
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiCreateDatabaseTableRowRequest) ClientSessionId(clientSessionId string) ApiCreateDatabaseTableRowRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiCreateDatabaseTableRowRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiCreateDatabaseTableRowRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

// If provided then the newly created row will be positioned before the row with the provided id.
func (r ApiCreateDatabaseTableRowRequest) Before(before int32) ApiCreateDatabaseTableRowRequest {
	r.before = &before
	return r
}

// A flag query parameter which if provided this endpoint will expect and return the user specified field names instead of internal Baserow field names (field_123 etc).
func (r ApiCreateDatabaseTableRowRequest) UserFieldNames(userFieldNames bool) ApiCreateDatabaseTableRowRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiCreateDatabaseTableRowRequest) ExampleRowRequestSerializerWithUserFieldNames(exampleRowRequestSerializerWithUserFieldNames ExampleRowRequestSerializerWithUserFieldNames) ApiCreateDatabaseTableRowRequest {
	r.exampleRowRequestSerializerWithUserFieldNames = &exampleRowRequestSerializerWithUserFieldNames
	return r
}

func (r ApiCreateDatabaseTableRowRequest) Execute() (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.CreateDatabaseTableRowExecute(r)
}

/*
CreateDatabaseTableRow Method for CreateDatabaseTableRow

Creates a new row in the table if the user has access to the related table's workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** to list them all. None of the fields are required, if they are not provided the value is going to be `null` or `false` or some default value is that is set. If you want to add a value for the field with for example id `10`, the key must be named `field_10`. Or instead if the `user_field_names` GET param is provided the key must be the name of the field. Of course multiple fields can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Creates a row in the table related to the provided value.
 @return ApiCreateDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) CreateDatabaseTableRow(ctx context.Context, tableId int32) ApiCreateDatabaseTableRowRequest {
	return ApiCreateDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) CreateDatabaseTableRowExecute(r ApiCreateDatabaseTableRowRequest) (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.CreateDatabaseTableRow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "")
	}
	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.exampleRowRequestSerializerWithUserFieldNames
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	rowId int32
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiDeleteDatabaseTableRowRequest) ClientSessionId(clientSessionId string) ApiDeleteDatabaseTableRowRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiDeleteDatabaseTableRowRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiDeleteDatabaseTableRowRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiDeleteDatabaseTableRowRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDatabaseTableRowExecute(r)
}

/*
DeleteDatabaseTableRow Method for DeleteDatabaseTableRow

Deletes an existing row in the table if the user has access to the table's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rowId Deletes the row related to the value.
 @param tableId Deletes the row in the table related to the value.
 @return ApiDeleteDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) DeleteDatabaseTableRow(ctx context.Context, rowId int32, tableId int32) ApiDeleteDatabaseTableRowRequest {
	return ApiDeleteDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		rowId: rowId,
		tableId: tableId,
	}
}

// Execute executes the request
func (a *DatabaseTableRowsApiService) DeleteDatabaseTableRowExecute(r ApiDeleteDatabaseTableRowRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.DeleteDatabaseTableRow")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/{row_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"row_id"+"}", url.PathEscape(parameterValueToString(r.rowId, "rowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DeleteDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAdjacentDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	rowId int32
	tableId int32
	previous *bool
	search *string
	userFieldNames *bool
	viewId *int32
}

// A flag query parameter which if provided returns theprevious row to the specified row_id. If it&#39;s not setit will return the next row.
func (r ApiGetAdjacentDatabaseTableRowRequest) Previous(previous bool) ApiGetAdjacentDatabaseTableRowRequest {
	r.previous = &previous
	return r
}

// If provided, the adjacent row will be one that matchesthe search query.
func (r ApiGetAdjacentDatabaseTableRowRequest) Search(search string) ApiGetAdjacentDatabaseTableRowRequest {
	r.search = &search
	return r
}

// A flag query parameter which if provided the returned json will use the user specified field names instead of internal Baserow field names (field_123 etc). 
func (r ApiGetAdjacentDatabaseTableRowRequest) UserFieldNames(userFieldNames bool) ApiGetAdjacentDatabaseTableRowRequest {
	r.userFieldNames = &userFieldNames
	return r
}

// Applies the filters and sorts of the provided view.
func (r ApiGetAdjacentDatabaseTableRowRequest) ViewId(viewId int32) ApiGetAdjacentDatabaseTableRowRequest {
	r.viewId = &viewId
	return r
}

func (r ApiGetAdjacentDatabaseTableRowRequest) Execute() (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.GetAdjacentDatabaseTableRowExecute(r)
}

/*
GetAdjacentDatabaseTableRow Method for GetAdjacentDatabaseTableRow

Fetches the adjacent row to a given row_id in the table with the given table_id. If the previous flag is set it will return the previous row, otherwise it will return the next row. You can specifya view_id and it will apply the filters and sorts of the provided view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rowId Returns the row adjacent the provided value.
 @param tableId Returns the row of the table related to the provided value.
 @return ApiGetAdjacentDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) GetAdjacentDatabaseTableRow(ctx context.Context, rowId int32, tableId int32) ApiGetAdjacentDatabaseTableRowRequest {
	return ApiGetAdjacentDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		rowId: rowId,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) GetAdjacentDatabaseTableRowExecute(r ApiGetAdjacentDatabaseTableRowRequest) (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.GetAdjacentDatabaseTableRow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/{row_id}/adjacent/"
	localVarPath = strings.Replace(localVarPath, "{"+"row_id"+"}", url.PathEscape(parameterValueToString(r.rowId, "rowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.previous != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "previous", r.previous, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetAdjacentDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	rowId int32
	tableId int32
	userFieldNames *bool
}

// A flag query parameter which if provided the returned json will use the user specified field names instead of internal Baserow field names (field_123 etc). 
func (r ApiGetDatabaseTableRowRequest) UserFieldNames(userFieldNames bool) ApiGetDatabaseTableRowRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiGetDatabaseTableRowRequest) Execute() (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.GetDatabaseTableRowExecute(r)
}

/*
GetDatabaseTableRow Method for GetDatabaseTableRow

Fetches an existing row from the table if the user has access to the related table's workspace. The properties of the returned row depend on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rowId Returns the row related the provided value.
 @param tableId Returns the row of the table related to the provided value.
 @return ApiGetDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) GetDatabaseTableRow(ctx context.Context, rowId int32, tableId int32) ApiGetDatabaseTableRowRequest {
	return ApiGetDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		rowId: rowId,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) GetDatabaseTableRowExecute(r ApiGetDatabaseTableRowRequest) (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.GetDatabaseTableRow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/{row_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"row_id"+"}", url.PathEscape(parameterValueToString(r.rowId, "rowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatabaseTableRowNamesRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId *string
}

// A list of comma separated row ids to query from the table with id {id}. For example, if you want the name of row &#x60;42&#x60; and &#x60;43&#x60; from table &#x60;28&#x60; this parameter will be &#x60;table__28&#x3D;42,43&#x60;. You can specify multiple rows for different tables but every tables must be in the same database. You need at least read permission on all specified tables.
func (r ApiListDatabaseTableRowNamesRequest) TableId(tableId string) ApiListDatabaseTableRowNamesRequest {
	r.tableId = &tableId
	return r
}

func (r ApiListDatabaseTableRowNamesRequest) Execute() (*ListDatabaseTableRowNames200Response, *http.Response, error) {
	return r.ApiService.ListDatabaseTableRowNamesExecute(r)
}

/*
ListDatabaseTableRowNames Method for ListDatabaseTableRowNames

Returns the names of the given row of the given tables. The nameof a row is the primary field value for this row. The result can be usedfor example, when you want to display the name of a linked row from another table.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDatabaseTableRowNamesRequest
*/
func (a *DatabaseTableRowsApiService) ListDatabaseTableRowNames(ctx context.Context) ApiListDatabaseTableRowNamesRequest {
	return ApiListDatabaseTableRowNamesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListDatabaseTableRowNames200Response
func (a *DatabaseTableRowsApiService) ListDatabaseTableRowNamesExecute(r ApiListDatabaseTableRowNamesRequest) (*ListDatabaseTableRowNames200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListDatabaseTableRowNames200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.ListDatabaseTableRowNames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/names/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tableId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "table__{id}", r.tableId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatabaseTableRowsRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	tableId int32
	exclude *string
	filterFieldFilter *string
	filterType *string
	include *string
	orderBy *string
	page *int32
	search *string
	size *int32
	userFieldNames *bool
	viewId *int32
}

// All the fields are included in the response by default. You can select a subset of fields by providing the exclude query parameter. If you for example provide the following GET parameter &#x60;exclude&#x3D;field_1,field_2&#x60; then the fields with id &#x60;1&#x60; and id &#x60;2&#x60; are going to be excluded from the selection and response. If the &#x60;user_field_names&#x60; parameter is provided then instead exclude should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;exclude&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;exclude&#x3D;My Field,Field with \\\&quot;&#x60;.
func (r ApiListDatabaseTableRowsRequest) Exclude(exclude string) ApiListDatabaseTableRowsRequest {
	r.exclude = &exclude
	return r
}

// The rows can optionally be filtered by the same view filters available for the views. Multiple filters can be provided if they follow the same format. The field and filter variable indicate how to filter and the value indicates where to filter on.  For example if you provide the following GET parameter &#x60;filter__field_1__equal&#x3D;test&#x60; then only rows where the value of field_1 is equal to test are going to be returned.  The following filters are available: equal, not_equal, filename_contains, has_file_type, contains, contains_not, contains_word, doesnt_contain_word, length_is_lower_than, higher_than, lower_than, date_equal, date_before, date_before_or_equal, date_after, date_after_or_equal, date_not_equal, date_equals_today, date_before_today, date_after_today, date_within_days, date_within_weeks, date_within_months, date_equals_days_ago, date_equals_months_ago, date_equals_years_ago, date_equals_week, date_equals_month, date_equals_day_of_month, date_equals_year, single_select_equal, single_select_not_equal, link_row_has, link_row_has_not, link_row_contains, link_row_not_contains, boolean, empty, not_empty, multiple_select_has, multiple_select_has_not, multiple_collaborators_has, multiple_collaborators_has_not.
func (r ApiListDatabaseTableRowsRequest) FilterFieldFilter(filterFieldFilter string) ApiListDatabaseTableRowsRequest {
	r.filterFieldFilter = &filterFieldFilter
	return r
}

// &#x60;AND&#x60;: Indicates that the rows must match all the provided filters. &#x60;OR&#x60;: Indicates that the rows only have to match one of the filters.  This works only if two or more filters are provided.
func (r ApiListDatabaseTableRowsRequest) FilterType(filterType string) ApiListDatabaseTableRowsRequest {
	r.filterType = &filterType
	return r
}

// All the fields are included in the response by default. You can select a subset of fields by providing the include query parameter. If you for example provide the following GET parameter &#x60;include&#x3D;field_1,field_2&#x60; then only the fields withid &#x60;1&#x60; and id &#x60;2&#x60; are going to be selected and included in the response. If the &#x60;user_field_names&#x60; parameter is provided then instead include should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;include&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;include&#x3D;My Field,Field with \\\&quot;&#x60;.
func (r ApiListDatabaseTableRowsRequest) Include(include string) ApiListDatabaseTableRowsRequest {
	r.include = &include
	return r
}

// Optionally the rows can be ordered by provided field ids separated by comma. By default a field is ordered in ascending (A-Z) order, but by prepending the field with a &#39;-&#39; it can be ordered descending (Z-A). If the &#x60;user_field_names&#x60; parameter is provided then instead order_by should be a comma separated list of the actual field names. For field names with commas you should surround the name with quotes like so: &#x60;order_by&#x3D;My Field,\&quot;Field With , \&quot;&#x60;. A backslash can be used to escape field names which contain double quotes like so: &#x60;order_by&#x3D;My Field,Field with \\\&quot;&#x60;.
func (r ApiListDatabaseTableRowsRequest) OrderBy(orderBy string) ApiListDatabaseTableRowsRequest {
	r.orderBy = &orderBy
	return r
}

// Defines which page of rows should be returned.
func (r ApiListDatabaseTableRowsRequest) Page(page int32) ApiListDatabaseTableRowsRequest {
	r.page = &page
	return r
}

// If provided only rows with data that matches the search query are going to be returned.
func (r ApiListDatabaseTableRowsRequest) Search(search string) ApiListDatabaseTableRowsRequest {
	r.search = &search
	return r
}

// Defines how many rows should be returned per page.
func (r ApiListDatabaseTableRowsRequest) Size(size int32) ApiListDatabaseTableRowsRequest {
	r.size = &size
	return r
}

// A flag query parameter which if provided the returned json will use the user specified field names instead of internal Baserow field names (field_123 etc). 
func (r ApiListDatabaseTableRowsRequest) UserFieldNames(userFieldNames bool) ApiListDatabaseTableRowsRequest {
	r.userFieldNames = &userFieldNames
	return r
}

// Includes all the filters and sorts of the provided view.
func (r ApiListDatabaseTableRowsRequest) ViewId(viewId int32) ApiListDatabaseTableRowsRequest {
	r.viewId = &viewId
	return r
}

func (r ApiListDatabaseTableRowsRequest) Execute() (*PaginationSerializerExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.ListDatabaseTableRowsExecute(r)
}

/*
ListDatabaseTableRows Method for ListDatabaseTableRows

Lists all the rows of the table related to the provided parameter if the user has access to the related database's workspace. The response is paginated by a page/size style. It is also possible to provide an optional search query, only rows where the data matches the search query are going to be returned then. The properties of the returned rows depends on which fields the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. In the example all field types are listed, but normally the number in field_{id} key is going to be the id of the field. Or if the GET parameter `user_field_names` is provided then the keys will be the name of the field. The value is what the user has provided and the format of it depends on the fields type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Returns the rows of the table related to the provided value.
 @return ApiListDatabaseTableRowsRequest
*/
func (a *DatabaseTableRowsApiService) ListDatabaseTableRows(ctx context.Context, tableId int32) ApiListDatabaseTableRowsRequest {
	return ApiListDatabaseTableRowsRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return PaginationSerializerExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) ListDatabaseTableRowsExecute(r ApiListDatabaseTableRowsRequest) (*PaginationSerializerExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginationSerializerExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.ListDatabaseTableRows")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.exclude != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude", r.exclude, "")
	}
	if r.filterFieldFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter__{field}__{filter}", r.filterFieldFilter, "")
	}
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_type", r.filterType, "")
	}
	if r.include != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include", r.include, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	if r.viewId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "view_id", r.viewId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ListDatabaseTableRows400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableRows404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMoveDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	rowId int32
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	beforeId *int32
	userFieldNames *bool
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiMoveDatabaseTableRowRequest) ClientSessionId(clientSessionId string) ApiMoveDatabaseTableRowRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiMoveDatabaseTableRowRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiMoveDatabaseTableRowRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

// Moves the row related to the given &#x60;row_id&#x60; before the row related to the provided value. If not provided, then the row will be moved to the end.
func (r ApiMoveDatabaseTableRowRequest) BeforeId(beforeId int32) ApiMoveDatabaseTableRowRequest {
	r.beforeId = &beforeId
	return r
}

// A flag query parameter which if provided the returned json will use the user specified field names instead of internal Baserow field names (field_123 etc). 
func (r ApiMoveDatabaseTableRowRequest) UserFieldNames(userFieldNames bool) ApiMoveDatabaseTableRowRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiMoveDatabaseTableRowRequest) Execute() (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.MoveDatabaseTableRowExecute(r)
}

/*
MoveDatabaseTableRow Method for MoveDatabaseTableRow

Moves the row related to given `row_id` parameter to another position. It is only possible to move the row before another existing row or to the end. If the `before_id` is provided then the row related to the `row_id` parameter is moved before that row. If the `before_id` parameter is not provided, then the row will be moved to the end.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rowId Moves the row related to the value.
 @param tableId Moves the row in the table related to the value.
 @return ApiMoveDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) MoveDatabaseTableRow(ctx context.Context, rowId int32, tableId int32) ApiMoveDatabaseTableRowRequest {
	return ApiMoveDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		rowId: rowId,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) MoveDatabaseTableRowExecute(r ApiMoveDatabaseTableRowRequest) (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.MoveDatabaseTableRow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/{row_id}/move/"
	localVarPath = strings.Replace(localVarPath, "{"+"row_id"+"}", url.PathEscape(parameterValueToString(r.rowId, "rowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.beforeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_id", r.beforeId, "")
	}
	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDatabaseTableRowRequest struct {
	ctx context.Context
	ApiService *DatabaseTableRowsApiService
	rowId int32
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	userFieldNames *bool
	patchedExampleUpdateRowRequestSerializerWithUserFieldNames *PatchedExampleUpdateRowRequestSerializerWithUserFieldNames
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiUpdateDatabaseTableRowRequest) ClientSessionId(clientSessionId string) ApiUpdateDatabaseTableRowRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiUpdateDatabaseTableRowRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiUpdateDatabaseTableRowRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

// A flag query parameter which if provided this endpoint will expect and return the user specified field names instead of internal Baserow field names (field_123 etc).
func (r ApiUpdateDatabaseTableRowRequest) UserFieldNames(userFieldNames bool) ApiUpdateDatabaseTableRowRequest {
	r.userFieldNames = &userFieldNames
	return r
}

func (r ApiUpdateDatabaseTableRowRequest) PatchedExampleUpdateRowRequestSerializerWithUserFieldNames(patchedExampleUpdateRowRequestSerializerWithUserFieldNames PatchedExampleUpdateRowRequestSerializerWithUserFieldNames) ApiUpdateDatabaseTableRowRequest {
	r.patchedExampleUpdateRowRequestSerializerWithUserFieldNames = &patchedExampleUpdateRowRequestSerializerWithUserFieldNames
	return r
}

func (r ApiUpdateDatabaseTableRowRequest) Execute() (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	return r.ApiService.UpdateDatabaseTableRowExecute(r)
}

/*
UpdateDatabaseTableRow Method for UpdateDatabaseTableRow

Updates an existing row in the table if the user has access to the related table's workspace. The accepted body fields are depending on the fields that the table has. For a complete overview of fields use the **list_database_table_fields** endpoint to list them all. None of the fields are required, if they are not provided the value is not going to be updated. When you want to update a value for the field with id `10`, the key must be named `field_10`. Or if the GET parameter `user_field_names` is provided the key of the field to update must be the name of the field. Multiple different fields to update can be provided in one request. In the examples below you will find all the different field types, the numbers/ids in the example are just there for example purposes, the field_ID must be replaced with the actual id of the field or the name of the field if `user_field_names` is provided.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param rowId Updates the row related to the value.
 @param tableId Updates the row in the table related to the value.
 @return ApiUpdateDatabaseTableRowRequest
*/
func (a *DatabaseTableRowsApiService) UpdateDatabaseTableRow(ctx context.Context, rowId int32, tableId int32) ApiUpdateDatabaseTableRowRequest {
	return ApiUpdateDatabaseTableRowRequest{
		ApiService: a,
		ctx: ctx,
		rowId: rowId,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return ExampleRowResponseSerializerWithUserFieldNames
func (a *DatabaseTableRowsApiService) UpdateDatabaseTableRowExecute(r ApiUpdateDatabaseTableRowRequest) (*ExampleRowResponseSerializerWithUserFieldNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExampleRowResponseSerializerWithUserFieldNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTableRowsApiService.UpdateDatabaseTableRow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/rows/table/{table_id}/{row_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"row_id"+"}", url.PathEscape(parameterValueToString(r.rowId, "rowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userFieldNames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user_field_names", r.userFieldNames, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.patchedExampleUpdateRowRequestSerializerWithUserFieldNames
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ListDatabaseTableFields401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CreateDatabaseTableRow404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

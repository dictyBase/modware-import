/*
Baserow API spec

For more information about our REST API, please visit [this page](https://baserow.io/docs/apis%2Frest-api).  For more information about our deprecation policy, please visit [this page](https://baserow.io/docs/apis%2Fdeprecations).

API version: 1.18.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DatabaseTablesApiService DatabaseTablesApi service
type DatabaseTablesApiService service

type ApiCreateDatabaseTableRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	databaseId int32
	tableCreate *TableCreate
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

func (r ApiCreateDatabaseTableRequest) TableCreate(tableCreate TableCreate) ApiCreateDatabaseTableRequest {
	r.tableCreate = &tableCreate
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiCreateDatabaseTableRequest) ClientSessionId(clientSessionId string) ApiCreateDatabaseTableRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiCreateDatabaseTableRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiCreateDatabaseTableRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiCreateDatabaseTableRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.CreateDatabaseTableExecute(r)
}

/*
CreateDatabaseTable Method for CreateDatabaseTable

Creates synchronously a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database's workspace.

As an alternative you can use the `create_async_database_table` for better performances and importing bigger files.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Creates a table for the database related to the provided value.
 @return ApiCreateDatabaseTableRequest
*/
func (a *DatabaseTablesApiService) CreateDatabaseTable(ctx context.Context, databaseId int32) ApiCreateDatabaseTableRequest {
	return ApiCreateDatabaseTableRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
	}
}

// Execute executes the request
//  @return Table
func (a *DatabaseTablesApiService) CreateDatabaseTableExecute(r ApiCreateDatabaseTableRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.CreateDatabaseTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/database/{database_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"database_id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tableCreate == nil {
		return localVarReturnValue, nil, reportError("tableCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.tableCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateDatabaseTable400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTables404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDatabaseTableAsyncRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	databaseId int32
	tableCreate *TableCreate
	clientSessionId *string
}

func (r ApiCreateDatabaseTableAsyncRequest) TableCreate(tableCreate TableCreate) ApiCreateDatabaseTableAsyncRequest {
	r.tableCreate = &tableCreate
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiCreateDatabaseTableAsyncRequest) ClientSessionId(clientSessionId string) ApiCreateDatabaseTableAsyncRequest {
	r.clientSessionId = &clientSessionId
	return r
}

func (r ApiCreateDatabaseTableAsyncRequest) Execute() (*SingleFileImportJobSerializerClass, *http.Response, error) {
	return r.ApiService.CreateDatabaseTableAsyncExecute(r)
}

/*
CreateDatabaseTableAsync Method for CreateDatabaseTableAsync

Creates a job that creates a new table for the database related to the provided `database_id` parameter if the authorized user has access to the database's workspace. This endpoint is asynchronous and return the created job to track the progress of the task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Creates a table for the database related to the provided value.
 @return ApiCreateDatabaseTableAsyncRequest
*/
func (a *DatabaseTablesApiService) CreateDatabaseTableAsync(ctx context.Context, databaseId int32) ApiCreateDatabaseTableAsyncRequest {
	return ApiCreateDatabaseTableAsyncRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
	}
}

// Execute executes the request
//  @return SingleFileImportJobSerializerClass
func (a *DatabaseTablesApiService) CreateDatabaseTableAsyncExecute(r ApiCreateDatabaseTableAsyncRequest) (*SingleFileImportJobSerializerClass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleFileImportJobSerializerClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.CreateDatabaseTableAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/database/{database_id}/async/"
	localVarPath = strings.Replace(localVarPath, "{"+"database_id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tableCreate == nil {
		return localVarReturnValue, nil, reportError("tableCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	// body params
	localVarPostBody = r.tableCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DuplicateTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTables404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabaseTableRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiDeleteDatabaseTableRequest) ClientSessionId(clientSessionId string) ApiDeleteDatabaseTableRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiDeleteDatabaseTableRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiDeleteDatabaseTableRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiDeleteDatabaseTableRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDatabaseTableExecute(r)
}

/*
DeleteDatabaseTable Method for DeleteDatabaseTable

Deletes the existing table if the authorized user has access to the related database's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Deletes the table related to the provided value.
 @return ApiDeleteDatabaseTableRequest
*/
func (a *DatabaseTablesApiService) DeleteDatabaseTable(ctx context.Context, tableId int32) ApiDeleteDatabaseTableRequest {
	return ApiDeleteDatabaseTableRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
func (a *DatabaseTablesApiService) DeleteDatabaseTableExecute(r ApiDeleteDatabaseTableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.DeleteDatabaseTable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DeleteDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDuplicateDatabaseTableAsyncRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiDuplicateDatabaseTableAsyncRequest) ClientSessionId(clientSessionId string) ApiDuplicateDatabaseTableAsyncRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiDuplicateDatabaseTableAsyncRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiDuplicateDatabaseTableAsyncRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiDuplicateDatabaseTableAsyncRequest) Execute() (*SingleDuplicateTableJobType, *http.Response, error) {
	return r.ApiService.DuplicateDatabaseTableAsyncExecute(r)
}

/*
DuplicateDatabaseTableAsync Method for DuplicateDatabaseTableAsync

Start a job to duplicate the table with the provided `table_id` parameter if the authorized user has access to the database's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId The table to duplicate.
 @return ApiDuplicateDatabaseTableAsyncRequest
*/
func (a *DatabaseTablesApiService) DuplicateDatabaseTableAsync(ctx context.Context, tableId int32) ApiDuplicateDatabaseTableAsyncRequest {
	return ApiDuplicateDatabaseTableAsyncRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return SingleDuplicateTableJobType
func (a *DatabaseTablesApiService) DuplicateDatabaseTableAsyncExecute(r ApiDuplicateDatabaseTableAsyncRequest) (*SingleDuplicateTableJobType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleDuplicateTableJobType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.DuplicateDatabaseTableAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/{table_id}/duplicate/async/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DuplicateTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseTableRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	tableId int32
}

func (r ApiGetDatabaseTableRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.GetDatabaseTableExecute(r)
}

/*
GetDatabaseTable Method for GetDatabaseTable

Returns the requested table if the authorized user has access to the related database's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Returns the table related to the provided value.
 @return ApiGetDatabaseTableRequest
*/
func (a *DatabaseTablesApiService) GetDatabaseTable(ctx context.Context, tableId int32) ApiGetDatabaseTableRequest {
	return ApiGetDatabaseTableRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return Table
func (a *DatabaseTablesApiService) GetDatabaseTableExecute(r ApiGetDatabaseTableRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.GetDatabaseTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportDataDatabaseTableAsyncRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	tableId int32
	tableImport *TableImport
}

func (r ApiImportDataDatabaseTableAsyncRequest) TableImport(tableImport TableImport) ApiImportDataDatabaseTableAsyncRequest {
	r.tableImport = &tableImport
	return r
}

func (r ApiImportDataDatabaseTableAsyncRequest) Execute() (*SingleFileImportJobSerializerClass, *http.Response, error) {
	return r.ApiService.ImportDataDatabaseTableAsyncExecute(r)
}

/*
ImportDataDatabaseTableAsync Method for ImportDataDatabaseTableAsync

Import data in the specified table if the authorized user has access to the related database's workspace. This endpoint is asynchronous and return the created job to track the progress of the task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Import data into the table related to the provided value.
 @return ApiImportDataDatabaseTableAsyncRequest
*/
func (a *DatabaseTablesApiService) ImportDataDatabaseTableAsync(ctx context.Context, tableId int32) ApiImportDataDatabaseTableAsyncRequest {
	return ApiImportDataDatabaseTableAsyncRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return SingleFileImportJobSerializerClass
func (a *DatabaseTablesApiService) ImportDataDatabaseTableAsyncExecute(r ApiImportDataDatabaseTableAsyncRequest) (*SingleFileImportJobSerializerClass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleFileImportJobSerializerClass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.ImportDataDatabaseTableAsync")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/{table_id}/import/async/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tableImport == nil {
		return localVarReturnValue, nil, reportError("tableImport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tableImport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatabaseTablesRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	databaseId int32
}

func (r ApiListDatabaseTablesRequest) Execute() ([]Table, *http.Response, error) {
	return r.ApiService.ListDatabaseTablesExecute(r)
}

/*
ListDatabaseTables Method for ListDatabaseTables

Lists all the tables that are in the database related to the `database_id` parameter if the user has access to the database's workspace. A table is exactly as the name suggests. It can hold multiple fields, each having their own type and multiple rows. They can be added via the **create_database_table_field** and **create_database_table_row** endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Returns only tables that are related to the provided value.
 @return ApiListDatabaseTablesRequest
*/
func (a *DatabaseTablesApiService) ListDatabaseTables(ctx context.Context, databaseId int32) ApiListDatabaseTablesRequest {
	return ApiListDatabaseTablesRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
	}
}

// Execute executes the request
//  @return []Table
func (a *DatabaseTablesApiService) ListDatabaseTablesExecute(r ApiListDatabaseTablesRequest) ([]Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.ListDatabaseTables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/database/{database_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"database_id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableField400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTables404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderDatabaseTablesRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	databaseId int32
	orderTables *OrderTables
	clientSessionId *string
	clientUndoRedoActionGroupId *string
}

func (r ApiOrderDatabaseTablesRequest) OrderTables(orderTables OrderTables) ApiOrderDatabaseTablesRequest {
	r.orderTables = &orderTables
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiOrderDatabaseTablesRequest) ClientSessionId(clientSessionId string) ApiOrderDatabaseTablesRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiOrderDatabaseTablesRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiOrderDatabaseTablesRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiOrderDatabaseTablesRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrderDatabaseTablesExecute(r)
}

/*
OrderDatabaseTables Method for OrderDatabaseTables

Changes the order of the provided table ids to the matching position that the id has in the list. If the authorized user does not belong to the workspace it will be ignored. The order of the not provided tables will be set to `0`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param databaseId Updates the order of the tables in the database related to the provided value.
 @return ApiOrderDatabaseTablesRequest
*/
func (a *DatabaseTablesApiService) OrderDatabaseTables(ctx context.Context, databaseId int32) ApiOrderDatabaseTablesRequest {
	return ApiOrderDatabaseTablesRequest{
		ApiService: a,
		ctx: ctx,
		databaseId: databaseId,
	}
}

// Execute executes the request
func (a *DatabaseTablesApiService) OrderDatabaseTablesExecute(r ApiOrderDatabaseTablesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.OrderDatabaseTables")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/database/{database_id}/order/"
	localVarPath = strings.Replace(localVarPath, "{"+"database_id"+"}", url.PathEscape(parameterValueToString(r.databaseId, "databaseId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderTables == nil {
		return nil, reportError("orderTables is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.orderTables
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v OrderDatabaseTables400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTables404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateDatabaseTableRequest struct {
	ctx context.Context
	ApiService *DatabaseTablesApiService
	tableId int32
	clientSessionId *string
	clientUndoRedoActionGroupId *string
	patchedTableUpdate *PatchedTableUpdate
}

// An optional header that marks the action performed by this request as having occurred in a particular client session. Then using the undo/redo endpoints with the same ClientSessionId header this action can be undone/redone.
func (r ApiUpdateDatabaseTableRequest) ClientSessionId(clientSessionId string) ApiUpdateDatabaseTableRequest {
	r.clientSessionId = &clientSessionId
	return r
}

// An optional header that marks the action performed by this request as having occurred in a particular action group.Then calling the undo/redo endpoint with the same ClientSessionId header, all the actions belonging to the same action group can be undone/redone together in a single API call.
func (r ApiUpdateDatabaseTableRequest) ClientUndoRedoActionGroupId(clientUndoRedoActionGroupId string) ApiUpdateDatabaseTableRequest {
	r.clientUndoRedoActionGroupId = &clientUndoRedoActionGroupId
	return r
}

func (r ApiUpdateDatabaseTableRequest) PatchedTableUpdate(patchedTableUpdate PatchedTableUpdate) ApiUpdateDatabaseTableRequest {
	r.patchedTableUpdate = &patchedTableUpdate
	return r
}

func (r ApiUpdateDatabaseTableRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.UpdateDatabaseTableExecute(r)
}

/*
UpdateDatabaseTable Method for UpdateDatabaseTable

Updates the existing table if the authorized user has access to the related database's workspace.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableId Updates the table related to the provided value.
 @return ApiUpdateDatabaseTableRequest
*/
func (a *DatabaseTablesApiService) UpdateDatabaseTable(ctx context.Context, tableId int32) ApiUpdateDatabaseTableRequest {
	return ApiUpdateDatabaseTableRequest{
		ApiService: a,
		ctx: ctx,
		tableId: tableId,
	}
}

// Execute executes the request
//  @return Table
func (a *DatabaseTablesApiService) UpdateDatabaseTableExecute(r ApiUpdateDatabaseTableRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseTablesApiService.UpdateDatabaseTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/database/tables/{table_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"table_id"+"}", url.PathEscape(parameterValueToString(r.tableId, "tableId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.clientSessionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientSessionId", r.clientSessionId, "")
	}
	if r.clientUndoRedoActionGroupId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "ClientUndoRedoActionGroupId", r.clientUndoRedoActionGroupId, "")
	}
	// body params
	localVarPostBody = r.patchedTableUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetDatabaseTableRow400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ListDatabaseTableFields404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
